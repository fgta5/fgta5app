import pgp from 'pg-promise'
import db from '../app-db.js'
import path from 'path'
import fs from 'fs/promises'
import ejs from 'ejs'
import { fileURLToPath } from 'url';
import { console } from 'inspector'

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);


export function parseTableName(str) {
	if (typeof str !== 'string' || !str.trim()) {
		throw new Error("Input harus berupa string non-kosong");
	}

	const parts = str.split('.');
	if (parts.length === 2) {
		const [schema, tablename] = parts;
		return { schema, tablename };
	} else if (parts.length === 1) {
		return { schema: 'public', tablename: parts[0] };
	} else {
		throw new Error("Format tidak valid. Gunakan 'schema.tablename' atau hanya 'tablename'");
	}
}

export async function tableExist(schema, tablename) {
	const sqlCekTableExists = `
		SELECT EXISTS (
			SELECT 1 
			FROM information_schema.tables 
			WHERE table_schema = \${schema}
			AND table_name = \${tablename}
		) AS "exists"		
	`
	
	try {
		const res = await db.one(sqlCekTableExists, {schema, tablename});
		return res.exists
	} catch (err) {
		throw err
	}
}

export async function fieldExists(schema, tablename, fieldname) {
	const sqlCekFieldExists = `
		SELECT EXISTS (
			SELECT 1
			FROM information_schema.columns
			WHERE table_schema = \${schema}
			AND table_name = \${tablename}
			AND column_name = \${fieldname}
		) AS "exists"	
	`

	try {
		const res = await db.one(sqlCekFieldExists, {schema, tablename, fieldname});
		return res.exists
	} catch (err) {
		throw err
	}	
} 

export async function createTable(schema, tablename, tabledescr, pk) {
	const {fieldname, datatype, length, precision, allownull, defaultvalue, description, identifierMethod} = pk

	try {

		// manual, auto-by-default, auto-always, auto-yearly, auto-monthly, custom

		let type
		if (['int', 'bigint'].includes(datatype)) {
			if (['auto-yearly', 'auto-monthly'].includes(identifierMethod)) {
				throw new Error(`identifier '${identifierMethod}' tidak bisa diterapkan untuk tipe data '${datatype}'`)
			} else if (identifierMethod=='auto-by-default') {
				// auto increment by default apabila tidak diisi
				type = `${datatype} generated by default as identity`

			} else if (identifierMethod=='auto-always') {
				// auto increment otomatis, tidak bisa diisi sendiri kecuali di ovveride counternya
				type = `${datatype} generated always as identity`
				
			} else {
				// manual or custome
				type = `${datatype} not null`
			}

		} else if (['char', 'varchar', 'text'].includes(datatype)) {
			if (['auto-bigint', 'auto-bigint-always', 'auto-int', 'auto-int-always'].includes(identifierMethod)) {
				throw new Error(`identifier '${identifierMethod}' tidak bisa diterapkan untuk tipe data '${datatype}'`)
			}

			if (type=='text') {
				type = `text not null`
			} else {
				type = `${datatype}(${length}) not null`
			}
		} else {
			throw new Error(`datatype '${datatype}' currently is not supported by generator`)
		}

		const variables = {
			schema,
			tablename,
			fieldname,
			type,
			tabledescr 
		}

		const tplFilePath = path.join(__dirname, 'templates', 'sqlCreateTable.ejs')
		const template = await fs.readFile(tplFilePath, 'utf-8');
		const sql = ejs.render(template, variables)

		// eksekusi create table
		if (!await tableExist(schema, tablename)) {
			await db.none(sql)
		}


		return sql
	} catch (err) {
		throw err
	}
}



export async function createField(schema, tablename, field) {
	const {fieldname, datatype, length, precision, allownull, defaultvalue, description} = field

	const script = []
	
	try {
		const type = getSqlDataType(datatype, length, precision)
		const sqlAdd = await sqlAddField(schema, tablename, field)
		const sqlModify = await sqlModifyField(schema, tablename, field)
		
		script.push('-- =============================================')
		script.push(`-- FIELD: ${fieldname} ${type}`)
		script.push('-- =============================================')
		script.push(sqlAdd)
		script.push(sqlModify)
		script.push('')


		if (await fieldExists(schema, tablename, fieldname)) {
			await db.none(sqlModify)
		} else {
			await db.none(sqlAdd)
		}

		return script.join("\n")
	} catch (err) {
		throw err
	}
}

function getSqlDataType(datatype, length, precision) {
	if (['char', 'varchar)'].includes(datatype)) {
		return `${datatype}(${length})`
	} else if (datatype=='decimal') {
		return `${datatype}(${length}, ${precision})`
	} else if (datatype=='timestamp') {
		return 'timestamp with time zone'
	} else {
		return datatype
	}
}

function defaultValueOf(datatype, defaultvalue, allownull) {
	if (['char', 'varchar', 'text'].includes(datatype)) {
		if (defaultvalue=='') {
			if (allownull) {
				return null
			} else {
				return `''`
			}
		} else {
			return `'${defaultvalue}'`	
		}
	} else if (['int', 'bigint', 'decimal'].includes(datatype)) {
		if (defaultvalue=='') {
			if (allownull) {
				return null
			} else {
				return '0'
			}
		} else {
			return defaultvalue
		}
	} else if (['date', 'time', 'timestamp'].includes(datatype)) {
		if (defaultvalue=='') {
			if (allownull) {
				return null
			} else {
				return '(now())'
			}
		} else {
			return defaultvalue
		}
	} else if (datatype=='boolean') {
		if (allownull) {
			return null
		} else {
			if (defaultvalue=='1' || defaultvalue =='true') {
				return true
			} else {
				return false
			}
		}
	} else {
		return defaultvalue
	}

}

async function sqlAddField(schema, tablename, f) {
	const {fieldname, datatype, length, precision, allownull, defaultvalue, description} = f

	try {

		const type = getSqlDataType(datatype, length, precision)
		const setnull = !allownull ? 'not null' : ''
		const value = defaultValueOf(datatype, defaultvalue, allownull)
		const setdefault = value!=null ? `default ${value}` : ''
		const variables = {
			schema,
			tablename,
			fieldname,
			type,
			setnull,
			setdefault,
			description
		}
		
		const tplFilePath = path.join(__dirname, 'templates', 'sqlAddField.ejs')
		const template = await fs.readFile(tplFilePath, 'utf-8');
		const sql = ejs.render(template, variables)
		return sql
	} catch (err) {
		throw err
	}
}

async function sqlModifyField(schema, tablename, f) {
	const {fieldname, datatype, length, precision, allownull, defaultvalue, description} = f

	try {
		const type = getSqlDataType(datatype, length, precision)
		const alternull = allownull ? `ALTER COLUMN ${fieldname} DROP NOT NULL` : `ALTER COLUMN ${fieldname} SET NOT NULL`
		const value = defaultValueOf(datatype, defaultvalue, allownull)
		const alterdefault = value==null ? `ALTER COLUMN ${fieldname} DROP DEFAULT` : `ALTER COLUMN ${fieldname} SET DEFAULT ${value}`
		const variables = {
			schema,
			tablename,
			fieldname,
			type,
			alterdefault,
			alternull,
			description
		}

		const tplFilePath = path.join(__dirname, 'templates', 'sqlModifyField.ejs')
		const template = await fs.readFile(tplFilePath, 'utf-8');
		const sql = ejs.render(template, variables)	
		return sql	
	} catch (err) {
		throw err
	}
}

export async function createUniqueIndex(schema, tablename, uniques) {
	const script = []

	script.push('-- =============================================')
	script.push(`-- UNIQUE INDEX`)
	script.push('-- =============================================')

	
	try {

		// Hapus semua existing unique index
		const sqlGetIniques = `
			SELECT constraint_name
			FROM information_schema.table_constraints
			WHERE constraint_type = 'UNIQUE'
				AND table_schema = \${schema}
				AND table_name = \${tablename};		
		`
		const existingUniques = await db.any(sqlGetIniques, {schema:schema, tablename:tablename});
		if (existingUniques.length>0) {
			const variables = {
				schema,
				tablename,
				existingUniques
			}
			const tplFilePath = path.join(__dirname, 'templates', 'sqlDropUniqueIndex.ejs')
			const template = await fs.readFile(tplFilePath, 'utf-8');
			const sqlDropUnique = ejs.render(template, variables)	

			await db.none(sqlDropUnique)

			script.push(sqlDropUnique)
		}

	

		// Tambahkan Unique Index
		const data = []
		for (let uniqName in uniques) {
			let uniq = uniques[uniqName]
			data.push({
				uniquename: `uq$${schema}$${tablename}$${uniq.name}`, 
				uniquefields:uniq.fields})
		} 

		if (data.length>0) {
			const variables = {
				schema,
				tablename,
				data
			}
			const tplFilePath = path.join(__dirname, 'templates', 'sqlAddUniqueIndex.ejs')
			const template = await fs.readFile(tplFilePath, 'utf-8');
			const sqlAddUnique = ejs.render(template, variables)	
			
			await db.none(sqlAddUnique)

			script.push(sqlAddUnique)
		}


		return script.join("\n")
	} catch (err) {
		throw err
	}
}


export async function createFereignKey(schema, tablename, foreignKeys) {
	// const {fk_name, fk_table, fk_field} = reference
	
	const script = []

	script.push('-- =============================================')
	script.push(`-- FOREIGN KEY CONSTRAINT`)
	script.push('-- =============================================')


	try {
		// Drop dulu referensi yang ada
		{
			const sqlGetFk = `
				SELECT constraint_name
				FROM information_schema.table_constraints
				WHERE constraint_type = 'FOREIGN KEY'
					AND table_schema = \${schema}
					AND table_name = \${tablename}
			`
			const existingFk = await db.any(sqlGetFk, {schema, tablename});
			if (existingFk.length>0) {
				const variables = {
					schema,
					tablename,
					existingFk
				}
				const tplFilePath = path.join(__dirname, 'templates', 'sqlDropForeignKey.ejs')
				const template = await fs.readFile(tplFilePath, 'utf-8');
				const sqlDropForeignKey = ejs.render(template, variables)	

				await db.none(sqlDropForeignKey)
				script.push(sqlDropForeignKey)
			}
		}


		// Tambahkan kembali foreign key
		{
			const fkList = []
			for (var fieldname in foreignKeys) {
				const field = foreignKeys[fieldname]
				const {data_fieldname, Reference} = field
				const ref_name = `fk$${schema}$${tablename}$${data_fieldname}`
				{
					const {schema, tablename} = parseTableName(Reference.table)
					Reference.ref_schema = schema
					Reference.ref_tablename = tablename
				}

				fkList.push({
					fieldname: data_fieldname,
					ref_name: ref_name,
					ref_schema: Reference.ref_schema,
					ref_tablename: Reference.ref_tablename,
					ref_fieldname: Reference.bindingValue
				})	

			}

			const variables = {
				schema,
				tablename,
				fkList
			}

			const tplFilePath = path.join(__dirname, 'templates', 'sqlAddForeignKey.ejs')
			const template = await fs.readFile(tplFilePath, 'utf-8');
			const sqlAddForeignKey = ejs.render(template, variables)	
			
			await db.none(sqlAddForeignKey)
			script.push(sqlAddForeignKey)
		}

		return script.join("\n")
	} catch (err) {
		throw err
	}
}